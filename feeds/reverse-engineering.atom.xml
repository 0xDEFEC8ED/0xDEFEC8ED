<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Diary of a Cybersec Enthusiast - reverse-engineering</title><link href="https://0xdefec8ed.github.io/" rel="alternate"></link><link href="https://0xdefec8ed.github.io/feeds/reverse-engineering.atom.xml" rel="self"></link><id>https://0xdefec8ed.github.io/</id><updated>2020-04-11T19:00:00+05:30</updated><entry><title>Analysing ELF Binaries</title><link href="https://0xdefec8ed.github.io/analysing-elf-binaries.html" rel="alternate"></link><published>2020-04-11T19:00:00+05:30</published><updated>2020-04-11T19:00:00+05:30</updated><author><name>samarth</name></author><id>tag:0xdefec8ed.github.io,2020-04-11:/analysing-elf-binaries.html</id><summary type="html">&lt;p&gt;When I was in middle school, I was introduced to this new kind of magical number system called "binary". Since then, I have always been facinated by 0's and 1's. I always wondered how some combinations of just 2 possibilities could build something so complex and beautiful as the internet …&lt;/p&gt;</summary><content type="html">&lt;p&gt;When I was in middle school, I was introduced to this new kind of magical number system called "binary". Since then, I have always been facinated by 0's and 1's. I always wondered how some combinations of just 2 possibilities could build something so complex and beautiful as the internet. I soon began to understand how things needed to be planned out before you start to build it. Reverse-Engineering is different. It needs practice. It requires experience. And you can never say that you've had enough of both to say that you are good at it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DISCLAIMER&lt;/strong&gt; : Most of the information in this article has been written from memory. I have sourced some material from this &lt;a href="https://www.amazon.com/Learning-Binary-Analysis-elfmaster-ONeill/dp/1782167102"&gt;amazing book&lt;/a&gt; or internet when needed. I know that it is very difficult to write an article on such a vast topic as binary analysis therefore I will try to accodomate as much information as I can without getting lost in this rabit hole. I wouldn't know how well this article will be drafted for a general audience before completing it and therefore I suggest further read if needed.
This topic offers a huge amount of information, and I am by no means an expert in this subject. I will still try to keep it short and convey my knowledge in this subjects through the written content as well as some references attached.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;What is an ELF file?&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;It is easy to define a file in terms of &lt;a href="https://en.wikipedia.org/wiki/Linux"&gt;Linux&lt;/a&gt;. - everything in linux is a file. And therefore I have decided to write this article based on the linux terminologies.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://man7.org/linux/man-pages/man5/elf.5.html"&gt;ELF&lt;/a&gt; is a File standard that is used to define a &lt;a href="https://en.wikipedia.org/wiki/Binary_file"&gt;binary&lt;/a&gt; file.
Binary files are coded to perform an action upon execution. It is a standard binary format for Linux and Unix-like systems on x86 processors. ELF64 is the revised standard for systems on x64 processors.&lt;/p&gt;
&lt;p&gt;A file is simply an abstract object filled with chunks of 0's and 1's that might not make sense when looked under a microscope, but when you zoom out a little, it begins to make patterns. Initially those patterns might seem too complex and tangled to be designed by a humans, but that is the true beauty that is facinating to me.&lt;/p&gt;
&lt;p&gt;I wish to explore how different systems are designed to parse an ELF binary and the elements revolving around it that makes those files breathe.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Important elements of a binary&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;A binary file is compiled in such a way that it needs to rely on the core components which must abide by the proposed ABI of the system it needs to be run on. &lt;a href="https://en.wikipedia.org/wiki/Linux_kernel_interfaces#Linux_ABI"&gt;ABI&lt;/a&gt; is similar to &lt;a href="https://en.wikipedia.org/wiki/Web_API"&gt;API&lt;/a&gt;, but it is different in a lot of ways since it is a term for much lower level components like Bootloader, Kernel, Operating System etc). We can also relate a binary executable to a program built for any embedded system such as &lt;strong&gt;8085&lt;/strong&gt;, &lt;strong&gt;8086&lt;/strong&gt; etc.&lt;/p&gt;
&lt;p&gt;Two of the most widely used binary formats are &lt;strong&gt;ELF&lt;/strong&gt; and &lt;strong&gt;PE&lt;/strong&gt; which are the standards on Linux and Windows systems respectively. All Modern computers perform their computations using binary number system which is defined by a set of rules to express all kinds of data in 1's and 0's. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ELF&lt;/strong&gt; is a file standard that most modern systems(read: linux) can understand as it is pretty well defined and most worked with. The two major sections defined in an ELF file are the "&lt;strong&gt;ELF Header&lt;/strong&gt;", and "&lt;strong&gt;File DATA&lt;/strong&gt;". ELF headers are always 64 bytes long for a 64 bit binary in a 64 bit platform and they contain the primary sets of information on how to interpret the file. &lt;strong&gt;File Data&lt;/strong&gt; consists of more header information and many different sections to properly organise the different components of the code that needs to be executed. File data is basicly the the main code that makes the file breathe.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ELF layout table" src="/static/images/Elf-layout.svg" title="Elf-layout.svg"&gt;&lt;/p&gt;
&lt;p&gt;The purpose of ELF header is simple, to inform the executer of the file (Operating system in general) of what it contains. Most of the information thaat you'd see when using a simple command such as &lt;code&gt;readelf&lt;/code&gt; on a binary is directly provided, or derived from the different headers of that file. For more information on ELF headers, you can go through the man page on &lt;a href="https://linux.die.net/man/5/elf"&gt;ELF&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The command &lt;code&gt;readelf -h&lt;/code&gt; will reveal all the header information on the binary.&lt;/p&gt;
&lt;p&gt;The header structure is not difficult to grasp. It always holds all the information as some kind of road map for the binary within the very first bytes of the file. Here is the ELF Header struct to get a gist of its purpose.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#define EI_NIDENT 16&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;e_ident&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;EI_NIDENT&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt;      &lt;span class="n"&gt;e_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt;      &lt;span class="n"&gt;e_machine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt;      &lt;span class="n"&gt;e_version&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ElfN_Addr&lt;/span&gt;     &lt;span class="n"&gt;e_entry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ElfN_Off&lt;/span&gt;      &lt;span class="n"&gt;e_phoff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ElfN_Off&lt;/span&gt;      &lt;span class="n"&gt;e_shoff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt;      &lt;span class="n"&gt;e_flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt;      &lt;span class="n"&gt;e_ehsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt;      &lt;span class="n"&gt;e_phentsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt;      &lt;span class="n"&gt;e_phnum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt;      &lt;span class="n"&gt;e_shentsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt;      &lt;span class="n"&gt;e_shnum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt;      &lt;span class="n"&gt;e_shstrndx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;fN_Ehdr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But wait,&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;How Are ELF Files Constructed?&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Binary files are &lt;strong&gt;compiled&lt;/strong&gt; from their source code which is can be written in various languages such as C, C++, Rust etc. Unforunately, I am still ill-informed on the compilation process of all other kinds of binaries other than C and therefore I can only write about different phases of compilation for a compiled binary in &lt;strong&gt;C&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="c-compilation-process" src="/static/images/c-compilation-process.png" title="c-compilation-process"&gt;&lt;/p&gt;
&lt;p&gt;A good C coder would know that even the most basic "HELLO WORLD" program cannot be built with just 6 lines of code without using pre-defined headers and macros which act as wrappers to the barebones of the &lt;strong&gt;ABI&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;First step of compilation process is called the &lt;strong&gt;preprocessing-phase&lt;/strong&gt;, wherein the compiler is tasked to expand the source code by copying in all the macros(#define) and header files(#include) so that all thats left in the source code is pure C code that is ready to get compiled.&lt;/p&gt;
&lt;p&gt;Second step is called &lt;strong&gt;compilation-phase&lt;/strong&gt;. The compilation phase takes the pre-processed code and translates it into assembly language. Most compilers also perform heavy optimization in this phase which can lead to differences in how disassembly of the the source code during this phase can and look like. keep in mind that the final binary is also derived from this phase and therefore any optimisations done by the compiler in this phase will affect the final outcome of the binary as well.&lt;/p&gt;
&lt;p&gt;Next step is called &lt;strong&gt;assembly phase&lt;/strong&gt;. The input of this phase is assembly code generated by the compiler and the output is actual &lt;strong&gt;machine code&lt;/strong&gt; which is provided as a set of object files(&lt;em&gt;.o). Object files contain machine instructions that are inprinciple executable by the processor and are really just a blob of binary. But we still need to do some work to produce a ready to run binary executable file. Typically, each source file corresponds to one assembly file, and each assembly file corresponds to one object file. Object files are &lt;/em&gt;&lt;em&gt;relocatable&lt;/em&gt;* type of ELF files. &lt;/p&gt;
&lt;p&gt;Object files are compiled independently from each other, so the assembler has no way of knowing the memory addresses of other object files when assembling an object file. That’s why object files need to be relocatable; that way,you can link them together in any order to form a complete binary executable.If object files were not relocatable, this would not be possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linking phase&lt;/strong&gt; is the final phase of the compilation process. As the name implies, this phase links together all the object files into a single binary executable. In modern systems, the linking phase some times incorporates an additional optimization pass, called link­ time optimization (LTO) or simply called, &lt;strong&gt;lazy linking&lt;/strong&gt;. The linker’s job is to take all the object files belonging to a program and merge them into a single coherent executable, typically intended to be loaded at a particular memory address. Now that the arrangement of all modules in the executable is known, the linker can also resolve most symbolic references. References to libraries may or may not be completely resolved, depending on the type of library.&lt;/p&gt;
&lt;p&gt;There are static libraries (file.a) and dynamic libraries (file.so). Static libraries are merged into the binary and therefore can be resolved entirely. Dynamic libraries are loaded into the memory only once, typically upon the startup of the system and the binary that wants to use this library has to share it with other executables as well as the system. During the linking phase, the addresses at which dynamic libraries will reside are not yet known, so references to them can not be resolved. Instead, the linker leaves symbolic references to these libraries even in the final executable, and these references are not resolved until the binary is actually loaded into memory to be executed(lazy linking). The final compiled executable can either be statically or dynamically linked. If the executable is dynamically linked, the interpreter header defined inside the ELF file tells us which dynamic linker will be used to resolve the dynamic libraries upon execution (typical interpreter for 64 bit system is /lib64/ld-linux-x86-64.so.2).&lt;/p&gt;
&lt;p&gt;Okay, I feel like I've successfully painted a picture of how trivial all this stuff is. Lets dive deeper.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Theory of the ELF standard, ELF headers&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;ELF files generally require only 2 kinds of headers,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ELF header&lt;/strong&gt; and the &lt;strong&gt;program header&lt;/strong&gt;, or&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ELF header&lt;/strong&gt; and the &lt;strong&gt;section header&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What I mean by required is that typically, the OS needs program headers to map the contents of the file in memory and section headers to further divide the contents into different sections (giving them labels) which is not required for a successful execution.&lt;/p&gt;
&lt;p&gt;When the C code that has been compiled to produce the binary contains external imports, as well as internal library function that are further meant to be exported, both program header and section headers are necessary. Program headers are a necessity to exist inside an executable file. They do not exist in relocatable objects because these *.o files are meant to be linked into an executable but not meant to be loaded directly into memory!&lt;/p&gt;
&lt;p&gt;Lets understand ELF files a bit more. ELF stands for Executable and Linkable Format. In general, I've mostly dealt with ELF files which are either plain old&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ET_EXEC&lt;/strong&gt; - Executable Files (typical C program with a main() function),&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ET_DYN&lt;/strong&gt;  - Shared Libraries(shared libraries are loaded and linked into a program's process image at runtime. eg &lt;code&gt;lib.so&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ET_REL&lt;/strong&gt;  - Relocatable object files (Position independent code(PIC) that have not yet been linked into an executable)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Shared libraries are compiled as position-independent and can therefore be easily relocated into a process address space. A shared library is a dynamic ELF object.&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I have skipped ET_NONE and ET_CORE types of files.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;strong&gt;Headers and their purpose&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ELF PROGRAM HEADER&lt;/strong&gt; : This header is used to describe &lt;strong&gt;SEGMENTS&lt;/strong&gt; (relate to memory segments in 8086) within the binary which is needed by the ABI layer to describe the memory layout of the executable. This header is needed for successful execution of a program. The size of the program headers can can vary as it holds information on different segments inside the executable. There is not much needed to know here other than the fact that the SEGMENTS are essentially a derivation from old school 8086 architecture and if you are fluent in it, it'll be easier for you to understand how things work better.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There are some values defined in the struct of program headers which are really interesting for use-cases where the executable which needs to be reversed is being percieved difficult for an initial learner. Most of these values are further used by the section headers to properly define the different sections that are essential for de-compilers. program header contains information (like size, offset and set values generally) on different segments and their permissions (for eg, READ+EXECUTE for text segment). Information on symbols table, string table, global offset table etc.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: We can easily calculate the size of the program header by doing e_phentsize * e_phnum&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ELF SECTION HEADER&lt;/strong&gt; : This header defines the &lt;strong&gt;SECTIONS&lt;/strong&gt; wich live inside the different &lt;strong&gt;SEGMENTS&lt;/strong&gt; of the executable. Within each segment, there is either code or data divided up into sections. A section header table exists to reference the location and size of these sections and is primarily for linking and debugging purposes. Section headers are not necessary for program execution, and a program will execute just fine without having a section header table. This is because the section header table doesn't describe the program memory layout. That is the responsibility of the program header table. &lt;/p&gt;
&lt;p&gt;Some interesting sections are,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.text&lt;/strong&gt;   : It contains the program code. The loader(linux-ld.so) loads instructions from here and executes them. It is often read only.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.rodata&lt;/strong&gt; : It holds all the read-only data such as strings from a line of C code such as a string defined in a printf() function.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.data&lt;/strong&gt;   : This section might contain more data, such as a string that is stored in a variable that is defined in an executable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.bss&lt;/strong&gt;    : All the uninitialized data is stored here. This consists of all global and static variables which are not initialized by the programmer. The kernel initializes them to arithmetic 0 by default.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.plt&lt;/strong&gt;    : This section contains information on the code which is being imported from an external library (in our case, functions like printf(), fgets() and strncmp()). The procedure linkage table (PLT) contains information for the dynamic linker to be able to call functions from used shared libraries.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.got.plt&lt;/strong&gt;: The global offset table (GOT) works together with the PLT to dynamically resolve and access imported shared library functions. This one is often attacked in GOT-overwrite exploits.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.dynsym&lt;/strong&gt; : This sections contains information about dynamic symbols imported from shared libraries e.g. printf from libc. These are dynamically loaded at runtime.&lt;/p&gt;
&lt;p&gt;I won't be looking into rest of the sections as I still want to keep this post short.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img alt="ghidra disassembler view" src="/static/images/exe-sc2.png" title="exe-sc2.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;&lt;strong&gt;ELF Symbols&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;ELF symbols table is derived from the section headers. Symbols are a symbolic reference to some type of data or code such as a global variable or function. For instance, &lt;strong&gt;the printf() function is going to have a symbol entry that points to it in the dynamic symbol table .dynsym&lt;/strong&gt;. In most shared libraries and dynamically linked executables, there exist two symbol tables. &lt;strong&gt;.dynsym and .symtab&lt;/strong&gt;. When a binary is stripped, all the entries on &lt;strong&gt;static symbols&lt;/strong&gt; is removed. Hence, symbols information is not a necessary condition for execution. In some statically compiled binaries, &lt;strong&gt;dynamic symbols&lt;/strong&gt; aren't needed as well.&lt;/p&gt;
&lt;p&gt;The .dynsym contains global symbols that reference symbols from an external  source, such as libc functions like printf, whereas the symbols contained in .symtab will contain all of the symbols in .dynsym, as well as the local symbols for the executable, such as global variables, or local functions that you have defined in your code. So .symtab contains all of the symbols, whereas .dynsym contains just  the dynamic/global symbols.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;existance of .symtab is not a necessary for proper execution of a (dynamically linked) binary&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;ELF dynamic linking&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;ELF files can be compiled statically or dynamically. There are various major differences between both kinds of binaries and in general, dynamic linking is a much more effecient way to go about handling shared libraries.&lt;/p&gt;
&lt;p&gt;An executable or shared object file's program header table is an array of structures, each describing a segment or other information that the system needs to prepare the program for execution.&lt;/p&gt;
&lt;p&gt;An object file segment contains one or more sections.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sections&lt;/strong&gt; are usually used to store code, data, and metadata (like debug info) in object files (.o) and are intended to be read by the linker. &lt;strong&gt;Object files don't contain much segment information&lt;/strong&gt;. The linker then reads in the sections from multiple object files and combines them. Since the linker is responsible for creating the segments in the final compiled binary, it only needs the &lt;strong&gt;section headers&lt;/strong&gt; of object files to properly place the intended object code inside the compiled binary.&lt;/p&gt;
&lt;p&gt;Executable and shared object files statically represent programs. When we execute these programs, the system uses these files(&lt;strong&gt;executable and object files only&lt;/strong&gt;) to create dynamic program representations, or process images. A process image has &lt;strong&gt;segments&lt;/strong&gt; that contain its text, data, stack, and so on.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;But what is dynamic linking?&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Shared libraries are compiled as position-independent and can therefore be easily relocated into a process address space. A shared library is a dynamic ELF object.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shared libraries (DLLs/dynamically linked libraries)&lt;/strong&gt; can be needed/called by multiple executables at a time, therefore the cannot be relocated inside a compiled binary every time.&lt;/p&gt;
&lt;p&gt;Dynamic objects are very similar to executables. They do not typically have a &lt;strong&gt;PT_INTERP(program header that contains the path to the program interpreter)&lt;/strong&gt; segment since they are loaded by the program interpreter, and therefore will not be invoking a program interpreter.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Instead of using the original executable file's segment images, the system composes a memory image for the interpreter. It then is the interpreter's responsibility to receive control from the system and provide an environment for the application program.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#interpreter"&gt;Solaris Docs&lt;/a&gt; on Dynamic linker says,&lt;/p&gt;
&lt;p&gt;&lt;a href="http://man7.org/linux/man-pages/man2/execve.2.html"&gt;sys_exec()&lt;/a&gt; and the dynamic linker cooperate to create the process image for the program, which entails the following actions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adding the executable file's memory segments to the process image;&lt;/li&gt;
&lt;li&gt;Adding shared object memory segments to the process image;&lt;/li&gt;
&lt;li&gt;Performing relocations for the executable file and its shared objects;&lt;/li&gt;
&lt;li&gt;Closing the file descriptor that was used to read the executable file, if one was given to the dynamic linker;&lt;/li&gt;
&lt;li&gt;Transferring control to the program, making it look as if the program had received control directly from exec(BA_OS).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Looking further for answers, &lt;a href="https://docs.oracle.com/cd/E19683-01/816-1386/6m7qcoblk/index.html#chapter6-71736"&gt;Oracle Docs&lt;/a&gt; says,&lt;/p&gt;
&lt;p&gt;The link-editor constructs various data for executable and shared object files that assist the runtime linker. These data reside in loadable segments, making them available during execution. These segments include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A .dynamic section with type SHT_DYNAMIC that holds various data. The structure residing at the beginning of the section holds the addresses of other dynamic linking information.&lt;/li&gt;
&lt;li&gt;The .got and .plt sections with type SHT_PROGBITS that hold two separate tables: the global offset table and the procedure linkage table. Sections below explain how the runtime linker uses and changes the tables to create memory images for object files.&lt;/li&gt;
&lt;li&gt;The .hash section with type SHT_HASH that holds a symbol hash table.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Shared objects can occupy virtual memory addresses that are different from the addresses recorded in the file's program header table. The runtime linker relocates the memory image, updating absolute addresses before the application gains control.&lt;/p&gt;
&lt;p&gt;Here is an overview on how an executable is loaded in the memory.&lt;/p&gt;
&lt;p&gt;&lt;img alt="loaded-elf-binary-on-linux" src="/static/images/loaded-elf-binary-on-linux.png" title="loaded-elf-binary-on-linux"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Okay!&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So when an executable which is dynamically linked gets executed, program interpreter, whose default path is stored in the PT_INTERP header gets invoked. The syscall, sys_execve() then communicates with the &lt;strong&gt;ABI&lt;/strong&gt; to map the executable into the memory. &lt;strong&gt;stack&lt;/strong&gt;, along with other necessary things are generated. The stack for that process address space is set up in a very specific way to pass information to the dynamic linker. This particular setup and arrangement of information is known as the &lt;strong&gt;auxiliary vector&lt;/strong&gt; or auxv. The &lt;a href="http://articles.manugarg.com/aboutelfauxiliaryvectors.html"&gt;auxiliary vector&lt;/a&gt; gets set up by a kernel function called create_elf_tables()that resides in the Linux source code /usr/src/linux/fs/binfmt_elf.c.&lt;/p&gt;
&lt;p&gt;[argc] [argv] [envp] [auxiliary] [.ascii data for argv/envp]&lt;/p&gt;
&lt;p&gt;Once a program is loaded into memory and the auxiliary vector has been filled in, control is passed to the dynamic linker. The dynamic linker resolves symbols and relocations for shared libraries that are linked into the process address space. By default, an executable is dynamically linked with the GNU C library libc.so.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;strong&gt;The PLT/GOT Sections&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;The PLT (procedure linkage table) and GOT (Global offset table) can be found in executable files and shared libraries. When a program calls a shared library function such as strcpy() or printf(), which are not resolved until runtime, &lt;strong&gt;dynamic linker&lt;/strong&gt; comes into play.&lt;/p&gt;
&lt;p&gt;Once the program has been executed and printf() has been called atleat once, a simple disassembly can show us that when printf() gets called again, the compiled code takes a jump onto the PLT jump table entry for printf(). This PLT table contains another jump entry to a different section. This address is a GOT (Global offset table) entry that holds the address to the actual printf() function in the libc shared library.&lt;/p&gt;
&lt;p&gt;All dynamically called function have a relocation entry of type R_386_JUMP_SLOT/R_X86_64_JUMP_SLOT at their GOT offsets. This means that the dynamic linker has to resolve the address of printf() and place its value into  the GOT entry for printf().&lt;/p&gt;
&lt;p&gt;Before the program gets executed, the GOT entry of the function call contains a &lt;strong&gt;jump back to the PLT entry of the function&lt;/strong&gt;, where a &lt;code&gt;push   $0x0&lt;/code&gt; is stored.&lt;/p&gt;
&lt;p&gt;The purpose of this push instruction is to push the GOT entry for printf() onto the stack. The GOT entry offset for printf() is 0x0, which corresponds to the first GOT entry that is reserved for a shared library symbol value, which is actually the fourth GOT entry, GOT[3]. In other words, the shared library addresses don't get plugged in starting at GOT[0] and they begin at GOT[3] (the fourth entry) because the first three are reserved for other purposes.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Take note of the following GOT offsets:&lt;/em&gt;
- &lt;em&gt;GOT[0] contains an address that points to the dynamic segment of the executable, which is used by the dynamic linker for extracting dynamic linking-related information.&lt;/em&gt;
- &lt;em&gt;GOT[1] contains the address of the link_map structure that is used by the dynamic linker to resolve symbols.&lt;/em&gt;
- &lt;em&gt;GOT[2] contains the address to the dynamic linkers _dl_runtime_resolve() function that resolves the actual symbol address for the shared library function.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The final printf() PLT instruction is a jmp to the PLT-0 code.&lt;/em&gt;
&lt;em&gt;The first instruction of PLT-0 pushes the address of GOT[1] onto the stack that contains an offset into the link_map struct for printf().&lt;/em&gt;
&lt;em&gt;The second instruction of PLT-0 is a jmp to the address in GOT[2] that points to the dynamic linker's _dl_runtime_resolve(), which then handles the R_386_JUMP_SLOT relocation by adding the symbol value (memory address) of printf() to its corresponding GOT entry in the .got.plt section.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The next time printf() is called, the PLT entry will jump directly to the function itself rather than having to perform the relocation procedure again.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;The magic of dynamic linkers&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;When the dynamic linker is mapped into memory, it first handles any of its own relocations if necessary; remember that the linker is a shared library itself. It then looks at the executable program's dynamic segment and searches for the DT_NEEDED tags that contain pointers to the strings or pathnames of the necessary shared libraries. When it maps a needed shared library into the memory, it accesses the library's dynamic segment (yes, they too have dynamic segments) and adds the library's symbol table to a chain of symbol tables that exists to hold the symbol tables for each mapped library.&lt;/p&gt;
&lt;p&gt;The linker creates a struct link_map entry for each shared library and stores it in a &lt;strong&gt;linked list&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Once the linker has finished building its list of dependencies, it handles the relocations on each library, as well as fixing up the GOT of each shared library. Lazy linking still applies to the PLT/GOT of shared libraries as well, so GOT relocations (of type R_386_JMP_SLOT) won't happen until the point when a function has actually been called.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Linker-related environment points&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;The dynamic loader/linker and linking concepts are inescapable components involved in the process of program linking and execution. In Linux, there are quite a few ways to alter the dynamic linker's behavior that can serve the binary hacker in many ways. There is an amazing POC published in an issue of &lt;a href="https://www.amazon.com/PoC-GTFO-Manul-Laphroaig/dp/1593278802"&gt;POC||GTFO&lt;/a&gt; which explores the method of writing a binary that utilises the features of the linker. &lt;/p&gt;
&lt;h5&gt;The LD_PRELOAD environment variable&lt;/h5&gt;
&lt;p&gt;The LD_PRELOAD environment variable can be set to specify a library path that should be dynamically linked before any other libraries. This has the effect of allowing functions and symbols from the preloaded library to override the ones from the other libraries that are linked afterwards. This essentially allows you to perform runtime patching by redirecting shared library functions. &lt;/p&gt;
&lt;p&gt;This technique can be used to bypass anti-debugging code and for userland rootkits.&lt;/p&gt;
&lt;h5&gt;Linker scripts&lt;/h5&gt;
&lt;p&gt;Linker scripts are a point of interest to us because they are interpreted by the linker and help shape a program's layout with regard to sections, memory, and symbols. The default linker script can be viewed with &lt;em&gt;ld -verbose&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The ld command language is quite an in-depth language and is beyond the scope of this book, but it is worth checking out. And while reverse engineering executables, remember that common segment addresses may sometimes be modified, and so can other portions of the layout. This indicates that a custom linker script is involved. A linker script can be specified with gcc using the -T flag.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Callback to Homebase, Some Important Points&lt;/h3&gt;
&lt;p&gt;This was a lot of information already, but I hope you’re still following along.&lt;/p&gt;
&lt;p&gt;To summarize, we now know the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;An ELF header resides at the beginning and holds a road map describing the files organization.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A program header within the program header table is necessary for an executable file to map the binary correctly into memory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A section within the section header table holds object file information for the linking view like instructions, data, symbol table, relocation information, and more, but is optional for executable files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamically linked binaries are parsed by the system in two different ways. Once by the kernel through execve() syscall and later by the dynamic linker. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here is a simple Python script I found recently to start the disassembly part using &lt;a href="http://www.capstone-engine.org/lang_python.html"&gt;capstone&lt;/a&gt; &lt;strong&gt;python's elftools&lt;/strong&gt; package. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;elftools.elf.elffile&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ELFFile&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;capstone&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;process_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;rb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;elffile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ELFFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;elffile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_section_by_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;.text&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;opcodes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sh_addr&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Entry Point:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;elffile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;e_entry&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;md&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Cs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS_ARCH_X86&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CS_MODE_64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;md&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;disasm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcodes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;0x&lt;/span&gt;&lt;span class="si"&gt;%x&lt;/span&gt;&lt;span class="s2"&gt;:&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mnemonic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;op_str&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;process_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;“If you know the enemy and know yourself, you need not fear the result of a hundred battles.
 If you know yourself but not the enemy, for every victory gained you will also suffer a defeat.
 If you know neither the enemy nor yourself, you will succumb in every battle.”  - Sun Tzu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;refs and further readings:&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://0x00sec.org/t/dissecting-and-exploiting-elf-files/7267"&gt;Dissecting and Exploiting ELFs, more info on readelf&lt;/a&gt;
&lt;a href="https://binaryresearch.github.io/2019/09/17/Analyzing-ELF-Binaries-with-Malformed-Headers-Part-1-Emulating-Tiny-Programs.html"&gt;Analysing ELF binaries with malformed headers&lt;/a&gt;
&lt;a href="https://anee.me/reversing-an-elf-from-the-ground-up-4fe1ec31db4a"&gt;Reversing an ELF from ground up&lt;/a&gt;
&lt;a href="https://github.com/thorkill/eresi"&gt;A collection of Awesome tools to analyse ELFs&lt;/a&gt;
&lt;a href="http://www.phrack.org/archives/issues/61/8.txt"&gt;A phrack article on exploiting ELFs&lt;/a&gt;&lt;/p&gt;</content><category term="reverse-engineering"></category><category term="reverse-engineering"></category><category term="primer"></category></entry></feed>